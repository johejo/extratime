package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
)

var (
	repoPath string
)

func init() {
	out, err := exec.Command("git", "rev-parse", "--show-toplevel").Output()
	if err != nil {
		panic(err)
	}
	repoPath = strings.TrimSpace(string(out))
}

func main() {
	if err := _main(); err != nil {
		log.Fatal(err)
	}
}

func _main() error {
	layouts := []struct {
		name    string
		genImpl bool
	}{
		{"ANSIC", true},
		{"UnixDate", true},
		{"RFC1123", true},
		{"RFC1123Z", true},
		{"RFC822", true},
		{"RFC822Z", true},
		{"RFC850", true},
		{"Kitchen", true},
		{"Stamp", true},
		{"StampMilli", true},
		{"StampMicro", true},
		{"StampNano", true},
		{"RubyDate", true},
		{"UnixTimeStamp", false},
	}

	b := new(bytes.Buffer)

	fprintf(b, "package extratime")
	fprintf(b, "// This file is auto-generated by internal/gen.go. DO NOT EDIT.")
	fprintf(b, "//go:generate go run internal/gen.go")
	fprintf(b, "import (")
	fprintf(b, `"encoding/xml"`)
	fprintf(b, `"encoding/json"`)
	fprintf(b, `"time"`)
	fprintf(b, ")")

	// type alias and named type
	fprintf(b, "type (")
	for _, layout := range layouts {
		l := layout.name
		fprintf(b, "%s struct{time.Time}", l)
	}
	fprintf(b, ")")

	pkgs := []string{
		"json",
		"xml",
	}
	ifs := []string{
		"Unmarshaler",
		"Marshaler",
	}
	// interface checker
	fprintf(b, "var (")
	for _, layout := range layouts {
		l := layout.name
		for _, p := range pkgs {
			for _, i := range ifs {
				fprintf(b, "_ %s.%s = (*%s)(nil)", p, i, l)
			}
		}
	}
	fprintf(b, ")")

	interfaces := map[string]struct {
		in, out string
	}{
		"MarshalJSON":   {in: "", out: "([]byte, error)"},
		"MarshalXML":    {in: "e *xml.Encoder, start xml.StartElement", out: "error"},
		"UnmarshalJSON": {in: "data []byte", out: "error"},
		"UnmarshalXML":  {in: "d *xml.Decoder, start xml.StartElement", out: "error"},
	}
	keys := make([]string, 0, len(interfaces))
	for k := range interfaces {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// implements
	for _, layout := range layouts {
		l := layout.name

		if !layout.genImpl {
			continue
		}
		for _, k := range keys {
			inf := interfaces[k]
			var rt string
			if strings.HasPrefix(k, "Marshal") {
				rt = ""
			} else {
				rt = "*"
			}
			fprintf(b, "func (t %s%s) %s(%s) %s {", rt, l, k, inf.in, inf.out)
			switch k {
			case "UnmarshalJSON":
				fprintf(b, "tt, err := time.Parse(time.%s, trim(data))", l)
				fprintf(b, "if err != nil { return err }")
				fprintf(b, "t.Time = tt")
				fprintf(b, "return nil")
			case "MarshalJSON":
				fprintf(b, "return []byte(`\"`+t.Format(time.%s)+`\"`), nil", l)
			case "MarshalXML":
				fprintf(b, "return e.EncodeElement(t.Format(time.%s), start)", l)
			case "UnmarshalXML":
				fprintf(b, "var s string")
				fprintf(b, "if err := d.DecodeElement(&s, &start); err != nil { return err }")
				fprintf(b, "tt, err := time.Parse(time.%s, s)", l)
				fprintf(b, "if err != nil { return err }")
				fprintf(b, "t.Time = tt")
				fprintf(b, "return nil")
			default:
				return fmt.Errorf("unsupported method: %s", k)
			}
			fprintf(b, "}")
		}
	}

	// test code
	t := new(bytes.Buffer)
	fprintf(t, "package extratime")
	fprintf(t, "// This file is auto-generated by internal/gen.go. DO NOT EDIT.")
	fprintf(t, "//go:generate go run internal/gen.go")
	fprintf(t, `import (`)
	fprintf(t, `"encoding/xml"`)
	fprintf(t, `"encoding/json"`)
	fprintf(t, `"strings"`)
	fprintf(t, `"time"`)
	fprintf(t, `"testing"`)
	fprintf(t, ``)
	fprintf(t, `"github.com/stretchr/testify/assert"`)
	fprintf(t, `)`)

	for _, layout := range layouts {
		if !layout.genImpl {
			continue
		}
		l := layout.name
		fprintf(t, "func Test%s_json(t *testing.T) {", l)
		fprintf(t, "    j := `{\"t\": \"`+strings.ReplaceAll(time.%s, \"_\", \" \")+`\"}`", l)
		fprintf(t, "    t.Log(j)")
		fprintf(t, "    var m map[string]%s", l)
		fprintf(t, "    assert.NoError(t, json.Unmarshal([]byte(j), &m))")
		fprintf(t, "    b, err := json.Marshal(m)")
		fprintf(t, "    assert.Nil(t, err)")
		fprintf(t, "    assert.JSONEq(t, j, string(b))")
		fprintf(t, "}")
	}

	for _, layout := range layouts {
		if !layout.genImpl {
			continue
		}
		l := layout.name
		fprintf(t, "func Test%s_xml(t *testing.T) {", l)
		fprintf(t, "    type A struct {")
		fprintf(t, "        XMLName xml.Name `xml:\"a\"`")
		fprintf(t, "        Text    string   `xml:\",chardata\"`")
		fprintf(t, "        B       %s       `xml:\"b\"`", l)
		fprintf(t, "    }")
		fprintf(t, `    v := strings.ReplaceAll(time.%s, "_", " ")`, l)
		fprintf(t, "    x := `<a><b>`+v+`</b></a>`")
		fprintf(t, "    t.Log(x)")
		fprintf(t, "    var a A")
		fprintf(t, "    assert.NoError(t, xml.Unmarshal([]byte(x), &a))")
		fprintf(t, "    b, err := xml.Marshal(a)")
		fprintf(t, "    assert.Nil(t, err)")
		fprintf(t, "    assert.Equal(t, x, string(b))")
		fprintf(t, "}")
	}

	test := filepath.Join(repoPath, "extratime_gen_test.go")
	if err := writeFile(test, t); err != nil {
		return err
	}

	dst := filepath.Join(repoPath, "extratime_gen.go")
	return writeFile(dst, b)
}

func fprintf(w io.Writer, format string, args ...interface{}) {
	_, _ = fmt.Fprintf(w, "\n"+format, args...)
}

func writeFile(filename string, src io.Reader) error {
	b, err := ioutil.ReadAll(src)
	if err != nil {
		return err
	}
	formatted, err := format.Source(b)
	if err != nil {
		return err
	}
	return ioutil.WriteFile(filename, formatted, 0o600)
}
